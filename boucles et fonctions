{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Nous allons nous intéresser maintenant à deux trois choses importantes dont nous allons avoir besoin pour la suite:\n",
    "    les boucles\n",
    "    le hasard\n",
    "    les fonctions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## les boucles:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "une boucle est un ensemble d instructions qui vont permettre de répéter une ou plusieurs opérations de façon séquentielle.\n",
    "Une boucle peut se contrôler grace à un paramètre de comparaison qui sera itéré à chaque exécution de la boucle (il augmente d'une unité)\n",
    "ou être infinie (cas des interaces graphiques en python)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### la boucle de type for"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(1,5):\n",
    "    print(i)\n",
    "print(\"fin de boucle\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "si vous exécutez cette boucle vous allez voir que c est assez simple, l' itérateur est la variable i\n",
    "on commence à donner la première valeur à i, i=1 grace à la fonction range(1,5), puis on imprime la valeur que contient i\n",
    "(vous remarquerez que l'instruction d'impression est indentée, décalée vers la droite, c'est grâce à cel que python comprend qu'elle est dans la boucle)\n",
    "i est alors incrémenté de 1 et prends la valeur 2 cette valeur est comparée au contenue dans la liste crée par la fonction range(1,5).\n",
    "et on recommence.\n",
    "au moment où i=5 la boucle s'interrompt.\n",
    "on affiche alors \"fin de boucle\"\n",
    "FACILE NON ?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On peut également envisager ça d'une autre façon:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "uneliste=['banane',9,43,125.68,'carotte',12,'bleue']\n",
    "for element in uneliste:\n",
    "    print(element)\n",
    "print(\"fin de boucle\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "on peut donc également se baser sur le contenu d'une liste ce qui est pratique.\n",
    "Vous remarquerez qu'une liste peut contenir des nombres comme des mots...on peut même mettre des variables dedans."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### la boucle de type while"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "c'est peut être plus facile à aborder parceque plus parlant quand on observe le code\n",
    "reprenons le même programme que tout à l'heure"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "i=1\n",
    "while i<5:\n",
    "    print(i)\n",
    "    i=i+1\n",
    "print('fin de boucle')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ça donne la même chose, mais avec un code plus étendu..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## le hasard"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Le hasard se gère assez facilement dans python car il existe une bibliothèque spéciale pour cela: random.\n",
    "On devra donc au préalable appeler celle-ci dans un programme quand on en aura besoin.\n",
    "Faisons quelques essais simples pour comprendre comme ça fonctionne."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n"
     ]
    }
   ],
   "source": [
    "from random import *\n",
    "\n",
    "n=randint(1,10)\n",
    "print(n)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ce petite bout de code importe dans la mémoire machine toutes les fonctions contenues dans la bibliothèque nommée random.\n",
    "on crée une variable qui peut prendre des valeurs dans une fourchette comprise entre 1 et 10 au hasard\n",
    "on affiche la valeur tirée au sort :)\n",
    "    trop bon !"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Du coup on peut être un peu audacieux...On essaye de combiner les boucles et random pour voir.\n",
    "ça peut donner ça."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from random import *\n",
    "i=1\n",
    "while i<20:\n",
    "    n=randint(1,40)\n",
    "    print(n)\n",
    "    i=i+1\n",
    "print('fin de boucle')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "on peut aussi éventuellement tirer au hasard dans une liste...ça c'est rigolo du coup !"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "43\n"
     ]
    }
   ],
   "source": [
    "from random import *\n",
    "\n",
    "uneliste=['banane',9,43,125.68,'carotte',12,'bleue']\n",
    "tirage=choice(uneliste)\n",
    "print(tirage)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "on a utilisé ici la fonction \"choice\" qui prend au hasard un élément de la liste \"uneliste\"..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## les fonctions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "nous avons déjà rencontré cette notion ne serait ce que juste au dessus de ce paragraphe avec des fonctions tirées de la bibliothèque random.\n",
    "On peut très bien créer nos propres fonctions dans un programme.\n",
    "Une fonction consiste à écrire de façon des lignes de codes dont l'enchainement va réaliser une tâche particulière, puis d'appeler la tâche quand on en aura besoin, là où on en aura besoin"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "un exemple en se basant sur ce que nous venons de voir"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6\n"
     ]
    }
   ],
   "source": [
    "from random import *\n",
    "\n",
    "def aleatoire():\n",
    "    valeur=randint(1,100)\n",
    "    return valeur\n",
    "\n",
    "print(aleatoire())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "on a définit une fonction qui réalise un tirage aléatoire entre 1 et 100, qui retourne un résultat accessible (\"return\")\n",
    "et ensuite on appelle la fonction pour l'exécuter quand on en a besoin.\n",
    "On peut aller un peut,par exemple appeler une fonction dans une boucle:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from random import *\n",
    "\n",
    "def tirage():\n",
    "    valeur=randint(1,100)\n",
    "    return valeur\n",
    "i=1\n",
    "while i<10:\n",
    "    print(tirage())\n",
    "    i=i+1\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## VOTRE JOB"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1) écrire un programme qui va tirer aléatoirement des valeurs de couleurs comprises dans une liste et afficher la valeur tirée...\n",
    "supposons que notre Simon peut afficher 6 couleurs (c'est un super simon):\n",
    "    rouge\n",
    "    vert\n",
    "    bleu\n",
    "    jaune\n",
    "    Cyan\n",
    "    Magenta"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2) faire la même chose mais faisant en sorte que Simon sorte 10 tirages consécutifs (donc une séquence aléatoire de 10 couleurs au sort)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3) reprendre le point 2 et faire en sorte que les résultats soient stockés dans une liste (chercher donc le fontionnement des listes dans python)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4) reprendre le point 2 mais faire en sorte que les résultats soient écrits dans un fichier ! ( on a déjà vu ça auparavant)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
